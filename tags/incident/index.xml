<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Incident on Home</title><link>https://abudlightlime.com/tags/incident/</link><description>Recent content in Incident on Home</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 28 Oct 2021 21:37:13 -0400</lastBuildDate><atom:link href="https://abudlightlime.com/tags/incident/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes Web Deployments, a love story</title><link>https://abudlightlime.com/posts/20211028-k8s-web-deployments/</link><pubDate>Thu, 28 Oct 2021 21:37:13 -0400</pubDate><guid>https://abudlightlime.com/posts/20211028-k8s-web-deployments/</guid><description>&lt;h3 id="the-wrong-tool-for-the-job">The wrong tool for the job?&lt;/h3>
&lt;p>Kubernetes is quickly becoming the default mechanism for engineers to manage remote deployments. Its feature-richness and ease of use make it an attractive solution for pushing work into the cloud. However, there still exist some quirks of its usage that any web developer should know before using it. This story tells of one of them.&lt;/p>
&lt;h3 id="what-happens-on-deployment">What happens on Deployment&lt;/h3>
&lt;p>For anyone who knows kubernetes, you&amp;rsquo;ll know that service deployments are rolled out in sets of pods. Each time you deploy a new version of your application, the old deployment slowly scales down while the new one scales up. In a deployment, each request is likely to be routed to any given pod so that means for some period of time in a rollout, your service is going to serve two versions of code simultaneously.&lt;/p></description></item></channel></rss>